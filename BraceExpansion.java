// Time Complexity : K^(N/K) -  depends on no. of braces and no of elements within each set of brace. Let K be the no. of braces and N be the total no. of elements. Then no of elements in each set of braces will be K/N
// Space Complexity : O(N), N-> length of string (for creating list of result)
// Did this code successfully run on Leetcode : Yes
// Any problem you faced while coding this : No

// Approach : I need to parse the elements within braces and backtrack once one path is explored. 
// All combinations need to be generated by selecting one element at a time from the elements within braces.

class Solution {
    public String[] expand(String S) {
        // edge case
        if(S == null || S.length() == 0) {
            return new String[]{};
        }
        
        // result
        List<String> result = new ArrayList<>();
        StringBuilder sb = new StringBuilder(); // for intermediate result
        
        createCombination(S, 0, sb, result);
        
        // convert result list to String array
        String[] res = new String[result.size()];
        for(int i = 0; i < result.size(); i++) {
            res[i] = result.get(i);
        }
        
        // sort result lexicographically
        Arrays.sort(res);
        
        return res;
    }
    
    private void createCombination(String s, int start, StringBuilder sb, List<String> result) {
        // goal state
        if(start >= s.length()) {
            result.add(sb.toString());
            return;
        }
        
        // main logic
        char ch = s.charAt(start);
        int currLen = sb.length();
        if(ch == '{') {
            int endIdx = s.indexOf('}',start+1);
            // create temporary string between braces to select one element at a time
            String tempStr = s.substring(start+1, endIdx); 
            for(int j = 0; j < tempStr.length(); j++) {
                // current character to add
                char curr = tempStr.charAt(j);
                if(curr != ',') {
                    sb.append(curr);
                    createCombination(s, endIdx+1, sb, result);
                    // backtrack
                    sb.setLength(currLen);
                }
            }
        }
        else {
            sb.append(ch);
            createCombination(s, start+1, sb, result);
        }
    }
}

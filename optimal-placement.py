'''
Optimal Placement of Buildings in a grid
Given a grid with w as width, h as height. Each cell of the grid represents a potential building lot and we will be adding "n" buildings inside this grid. The goal is for the furthest of all lots to be as near as possible to a building. Given an input n, which is the number of buildings to be placed in the lot, determine the building placement to minimize the distance the most distant empty lot is from the building. Movement is restricted to horizontal and vertical i.e. diagonal movement is not required.

For example, w=4, h=4 and n=3. An optimal grid placement sets any lot within two unit distance of the building. The answer for this case is 2.

"0" indicates optimal building placement and in this case the maximal value of all shortest distances to the closest building for each cell is "2".

1 0 1 2

2 1 2 1

1 0 1 0

2 1 2 1

'''
# TIME COMPLEXITY: O(height*width C buildings) - nCr -> Asymtotically, exponential
# SPACE COMPLEXITY: O(height*width)


class OptimalPlacement:
    def __init__(self, height, width, buildings):
        self.h = height
        self.w = width
        self.buildings = buildings
        # Initialize min dist
        self.min_dist = float('inf')
        # Generate a grid for given dimentions
        self.grid = [[-1 for _ in range(width)] for _ in range(height)]
        # Dirs array to visit neighbors of a cell
        self.dirs = ((0, 1), (1, 0), (-1, 0), (0, -1))

    def find_min_distance(self):
        # A combination of backtracking and BFS
        # The backtrack function tries all possible placements of n buildings
        # Use BFS to find the min distance for every placement generated by backtracking
        self._backtrack(self.grid, 0, 0, self.buildings)
        return self.min_dist

    def _backtrack(self, grid, r, c, n):
        # Base Case
        # If all the buildings are placed, call BFS on the grid configuration
        if n == 0:
            self._bfs(grid)
            return
        # If we are at the last column, move one row down, reset column to 0
        if c == self.w:
            r += 1
            c = 0
        # Try to place a building for all possible columns between c to width in the current row
        for i in range(r, self.h):
            for j in range(c, self.w):
                # Action
                grid[i][j] = 0
                # Recurse
                self._backtrack(grid, i, j + 1, n-1)
                # Backtrack
                grid[i][j] = -1

    def _bfs(self, grid):
        # Initialize queue and visited set
        q = collections.deque()
        visited = set()
        # Add all cells with a building to queue
        for i in range(self.h):
            for j in range(self.w):
                if grid[i][j] == 0:
                    q.append((i, j))
                    visited.add((i, j))
        # Initialize distance to 0
        distance = 0
        # BFS
        while q:
            size = len(q)
            for _ in range(size):
                r, c = q.popleft()
                for dir in self.dirs:
                    nr = r + dir[0]
                    nc = c + dir[1]
                    if 0 <= nr < self.h and 0 <= nc < self.w and (nr, nc) not in visited:
                        q.append((nr, nc))
                        visited.add((nr, nc))
            # Increment distance after every level
            distance += 1
        # At the end of BFS, distance holds the maximal distance for a given placement configuration
        # Update global minumum distance
        self.min_dist = min(self.min_dist, distance - 1)


def main():
    p = OptimalPlacement(4, 4, 3)
    print(p.find_min_distance())


main()
